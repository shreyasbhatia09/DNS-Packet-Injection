CSE508: Network Security, Fall 2017

Homework 4: DNS Packet Injection
-------------------------------------------------------------------------------

The aim of this assignment was to develop 
1) an on-path DNS packet injector
2) a passive DNS poisoning attack detector.


Part 1:

Overview
-------------------------------------------------------------------------------
The DNS packet injector which we developed, named 'dnsinject.py', will
capture the traffic from a network interface in promiscuous mode, and attempt
to inject forged responses to selected DNS A requests with the goal to poison
the resolver's cache.

The program has the following parameters

sudo python dnsinject.py [-i interface] [-h hostnames] expression

-i  Listen on network device <interface> (e.g., eth0). If not specified,
    dnsinject should select a default interface to listen on. The same
    interface should be used for packet injection.

-h  Read a list of IP address and hostname pairs specifying the hostnames to
    be hijacked. If '-h' is not specified, dnsinject should forge replies for
    all observed requests with the local machine's IP address as an answer.

<expression> is a BPF filter that specifies a subset of the traffic to be
monitored.


Environment
----------------------------
Distributor ID:	Ubuntu
Description:	Ubuntu 16.04.3 LTS
Release:	16.04
Codename:	xenial
Kernel:		Linux 4.10.0-38-generic x86_64
Python Version:	Python 2.7.12

Dependencies
-------------------------------------------------------------------------------
The script depends on the following dependcies.
1) scapy (http://scapy.readthedocs.io/en/latest/installation.html)
2) netifaces (sudo apt-get install python-netifaces for Ubuntu) 

General Design 
-------------------------------------------------------------------------------
The dnsinject script is based on an object oriented approach. The class DnsInject has the implementation for the same.
If an interface is passed then that sniffing happens on that same interface otherwise the script will get a list of interfaces and then
select one of them (except loopback). Also, the ip associated with the interface is also stored. 

The start_dnsspoof function will start injecting spoof packets. If a host file is provided, it will spoof those requests which are there in the file. If no, file is provided then it will spoof all dns request packets. DNS requests can be over TCP and UDP. These cases are handled in the script. We will construct a packet with the same values from the original packet except for the rdata. The rdata attribute of the spoofed packet will contain the local IP(if no hostfile is specified) otherwise, it will take it from the list. Once, the packet is ready it will send the packet as a spoofed response.


Example Commands 
-------------------------------------------------------------------------------
1) sudo python dnsinject.py -i wlp6s0 -h hostname
2) sudo python dnsinject.py -h hostname
3) sudo python dnsinject.py

Part 2:


Overview
-------------------------------------------------------------------------------
The DNS poisoning attack detector we developed, named 'dnsdetect',
will capture the traffic from a network interface in promiscuous mode and
detect DNS poisoning attack attempts, such as those generated by dnsinject.
Detection will be based on identifying duplicate responses towards the same
destination that contain different answers for the same A request, i.e., the
observation of the attacker's spoofed response followed by the server's actual
response.

Usage- 
sudo python dnsdetect.py [-i interface] [-r tracefile] expression

-i  Listen on network device <interface> (e.g., eth0). If not specified,
    the program should select a default interface to listen on.

-r  Read packets from <tracefile> (tcpdump format). Useful for detecting
    DNS poisoning attacks in existing network traces.

<expression> is a BPF filter that specifies a subset of the traffic to be
monitored.


Environment 
-------------------------------------------------------------------------------
Distributor ID:	Ubuntu
Description:	Ubuntu 16.04.3 LTS
Release:	16.04
Codename:	xenial
Kernel:		Linux 4.10.0-38-generic x86_64
Python Version:	Python 2.7.12

Dependencies
-------------------------------------------------------------------------------
The script depends on the following dependcies.
1) scapy (http://scapy.readthedocs.io/en/latest/installation.html)
2) netifaces (sudo apt-get install python-netifaces for Ubuntu) 

General Design
-------------------------------------------------------------------------------
The DNSDetector class implements the logic for 'dnsdetect'. The script accepts two parameters -i and -r. To sniff on a particular interface -i is used. If specified the script will only sniff packets from that interface only. If -r is specified, it will sniff the packets from the pcap file only. 

Handling False Postives:
To detect dns spoof attack attempts we will store all the DNS Requst packets. For a new packet, we will compare it with the packets in the list and check wether the TXID and query name matches or not. If they do match then we will iterate over all the answers from those two packets and check wether all of the IP's are equal or not. For this, we are using two lists which will store the answer IP's and then will find the intersection of these two using by converting them into sets (Since sets are implemented using hashing). If the intersection contains something that means there is a spoofing attempt. Hence, we will print to the stdout, the details about the attack attempt. By doing so, we are decreasing the number of false positives because we are not directly comparing the rdata field from the response. Since there could be multiple values in the 'Answer section' we are checking all of them against other packets to check for the attack attempt.

Example Commands 
-------------------------------------------------------------------------------
1) sudo python dnsdetect.py -i wlp6s0 -h hostname
2) sudo python dnsdetect.py -h hostname
3) sudo python dnsdetect.py

